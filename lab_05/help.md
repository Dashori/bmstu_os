ftok - преобразовывает имя файла и идентификатор проекта в ключ для системных вызовов для работы с msgget(2), semget(2), и shmget(2).

Как видно, встает проблема именования разделяемого ресурса: необходим некий механизм получения заведомо уникального ключа для именования ресурса, но вместе с тем нужно, чтобы этот механизм позволял всем процессам, желающим работать с одним ресурсом, получить одно и то же значение ключа.

Для решения этой задачи служит функция ftok():

key_t ftok(const char *pathname, int proj_id);  

key == -1 ERROR

Эта функция генерирует значение ключа по некоторой строке символов и добавочному символу, передаваемым в качестве параметров. Гарантируется, что полученное таким образом значение будет отличаться от всех других значений, сгенерированных функцией ftok() с другими значениями параметров, и в то же время, при повторном запуске ftok() с теми же параметрами, будет получено то же самое значение ключа.

Смысл второго аргумента функции ftok() – добавочного символа – в том, что он позволяет генерировать разные значения ключа по одному и тому же значению первого параметра – строки. Это позволяет программисту поддерживать несколько версий своей программы, которые будут использовать одну и ту же строку, но разные добавочные символы для генерации ключа, и тем самым получат возможность в рамках одной системы работать с разными разделяемыми ресурсами.

Следует заметить, что функция ftok() не является системным вызовом, а предоставляется библиотекой.



shmget - присваивает идентификатор разделяемому сегменту памяти  

Создается новый разделяемый сегмент памяти с размером size (округленным до размера, кратного PAGE_SIZE)

int shmget(key_t key, int size, int shmflg);  

Аргументы этого вызова: key - ключ для доступа к разделяемой памяти; size задает размер области памяти, к которой процесс желает получить доступ.
В случае успешного завершения вызов возвращает положительное число – дескриптор области памяти, в случае неудачи - -1.


int perms = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
int shmid = shmget(key, (2 * sizeof(char*)) + N + 1, IPC_CREAT | perms); //сказала не высчитывать и писать 256

IPC_CREAT служит для создания нового сегмента, если он ещё не был создан


shmat - подключает сегмент общей памяти System V с идентификатором shmid к адресному пространству вызывающего процесса. Адрес подключения, указанный в shmaddr.

При помощи этого вызова процесс подсоединяет область разделяемой памяти, дескриптор которой указан в shmid, к своему виртуальному адресному пространству. 

Третий аргумент представляет собой комбинацию флагов. В качестве значения этого аргумента может быть указан флаг SHM_RDONLY, который указывает на то, что подсоединяемая область будет использоваться только для чтения.
Эта функция возвращает адрес, начиная с которого будет отображаться присоединяемая разделяемая память. В случае неудачи вызов возвращает -1.

void *shmat(int shmid, const void *shmaddr, int shmflg)

char *addr = shmat(shmid, NULL, 0);


int shmdt(char *shmaddr)
Данный вызов позволяет отсоединить разделяемую память, ранее присоединенную посредством вызова shmat().

Параметр shmaddr - адрес прикрепленной к процессу памяти, который был получен при вызове shmat().
В случае успешного выполнения функция возвращает 0, в случае неудачи -1
Если shmaddr равен NULL, то система выбирает для подстыкованного сегмента подходящий (неиспользованный) адрес.




semget()
int semget(key_t key, int nsems, int semflg);  

semget(key, 3, IPC_CREAT | perms);

Системный вызов возвращает идентификатор набора семафоров, связанный с аргументом key. Создается новый набор из семафоров nsems , если значение key равно IPC_PRIVATE или c ключом key не связано ни одного существующего набора семафора, а выражение semflg & IPC_CREAT истинно.

Первый параметр функции semget() – ключ для доступа к разделяемому ресурсу, второй - количество семафоров в создаваемом наборе (длина массива семафоров) и третий параметр – флаги, управляющие поведением вызова. 

При удачном завершении возвращаемое значение будет представлять собой идентификатор набора семафоров (целое неотрицательное значение), иначе возвращается -1


Используя полученный дескриптор, можно производить изменять значения одного или нескольких семафоров в наборе, а также проверять их значения на равенство нулю, для чего используется системный вызов semop():

int semop (int semid, struct sembuf *semop, size_t nops)

Этому вызову передаются следующие аргументы:

semid – дескриптор массива семафоров;

semop – массив из объектов типа struct sembuf, каждый из которых задает одну операцию над семафором;

nops – длина массива semop. Количество семафоров, над которыми процесс может одновременно производить операцию в одном вызове semop(), ограничено константой SEMOPM, описанной в файле <sys/sem.h>. Если процесс попытается вызвать semop() с параметром nops, большим этого значения, этот вызов вернет неуспех.

Структура имеет sembuf вид:

struct sembuf {

short sem_num; /* номер семафора в векторе */

short sem_op; /* производимая операция */

short sem_flg; /* флаги операции */

}

операции над семафорами
https://studfile.net/preview/7356455/page:47/



semctl - производит операции управления семафорами 


int semctl (int semid, int num, int cmd, union semun arg)

С помощью этого системного вызова можно запрашивать и изменять управляющие параметры разделяемого ресурса, а также удалять его.

Первый параметр вызова – дескриптор массива семафоров. Параметр num представляет собой индекс семафора в массиве, параметр cmd задает операцию, которая должна быть выполнена над данным семафором. Последний аргумент имеет тип union semun и используется для считывания или задания управляющих параметров одного семафора или всего массива, в зависимости от значения аргумента cmd



критическая секция где? одни процессы могуть писать и должны работать в режиме однопоточном?, а другие читать и могут параллельно
